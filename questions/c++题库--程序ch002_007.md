## ch002_007
``` c++
1)　#include<iostream>
2)　#include　<iomanip>
3)　using　namespace　std;
4)　int　main(){
5)　　　　　　cout<<　setprecision(18)　<<　"Real:"<<"12.3456789012345678901E20"<<　endl;
6)　　　　float　f　=　12.3456789012345678901E20;
7)　　　　cout　<<　setprecision(18)　<<　"float　:"　<<　f　<<　endl;
8)　　　　double　d　=　12.3456789012345678901E20;
9)　　　　cout　<<　setprecision(18)　<<　"double:"　<<　d　<<　endl;
10)　}

```
### 题目22758
问题：1.关于函数setprecision的作用说法正确的是：
A.　　没有用处
B.　　设定输出宽度
C.　　设定输出精度
D.　　设定数据类型


**解析如下：**

------

解析：
函数`setprecision`是C++中iomanip库中的一个操作符，用于设置输出的精度，即小数点后保留的位数。在这段代码中，`setprecision(18)`用于设置输出精度为18位。

代码运行结果分析：
- 第5行输出的是字符串，不受`setprecision`影响。
- 第7行将一个非常大的浮点数赋值给`float`类型的变量`f`，由于`float`类型的精度限制，输出结果可能会失真。
- 第9行将同样的数赋值给`double`类型的变量`d`，`double`类型的精度更高，输出结果更接近实际值。

正确答案是C，因为`setprecision`用于设定输出精度。

答案：'{"22758":"C"}'

------

### 题目22759
问题：2.VS环境中float的有效位（含隐藏位）数是：
A.　6
B.　10
C.　8
D.　9


**解析如下：**

------

解析：
在VS环境中，`float`类型的有效位数（含隐藏位）通常是7位到8位。具体来说，`float`类型采用IEEE 754标准，单精度浮点数有23位用于表示小数部分（尾数），加上一个隐藏的整数位1，总共是24位二进制数。换算成十进制，大约是7.22位有效数字。

选项中最接近的是C. 8。

答案：'{"22759":"C"}'

------

### 题目22760
问题：3.VS环境中double的有效位数是：
A.　15
B.　　16
C.　19
D.　　20


**解析如下：**

------

解析：
在VS环境中，`double`类型的有效位数通常是15位到17位。具体来说，`double`类型采用IEEE 754标准，双精度浮点数有52位用于表示小数部分（尾数），加上一个隐藏的整数位1，总共是53位二进制数。换算成十进制，大约是15.95位有效数字。

选项中最接近的是A. 15。

答案：'{"22760":"A"}'

------

### 题目22761
问题：4.long　double的有效位数是：
A.　15
B.　　16
C.　19
D.　　20


**解析如下：**

------

解析：
`long double`类型的有效位数在不同的编译器和平台上可能会有所不同。在VS环境中，`long double`通常具有更高的精度，通常在19到20位有效数字之间。

选项中最接近的是D. 20。

答案：'{"22761":"D"}'

------

### 题目22762
问题：5.头文件iomanip的作用是：
A.包含输入输出函数
B.包含格式输入输出函数
C.包含数学函数
D.包含控制函数


**解析如下：**

------

解析：
头文件`<iomanip>`是C++标准库中的一个头文件，主要用于包含格式化输入输出的函数和操作符，例如`setprecision`、`setw`等，用于控制输出格式。

选项B. 包含格式输入输出函数是正确的。

答案：'{"22762":"B"}'

------

### 题目22763
问题：6.执行该程序，屏幕输出第一行为：
A.　Real　　:12.3456789012345678901
B.　Real　　:12.3456789012345678901E20
C.　Real　　:12.345678901234567890120
D.　Real　　:12.345678901234567890100


**解析如下：**

------

解析：
第5行代码 `cout << setprecision(18) << "Real:" << "12.3456789012345678901E20" << endl;` 中，`"12.3456789012345678901E20"` 是一个字符串，`setprecision` 对字符串没有影响，所以会原样输出。

因此，屏幕输出第一行为 `Real:12.3456789012345678901E20`。

正确答案是B。

答案：'{"22763":"B"}'

------

### 题目22764
问题：7.　执行该程序，屏幕输出第二行为：
A.　　float　:12.345678901234567e+020
B.　　float　:12.345678252014001e+020
C.　　float　:1.2345678901234567e+021
D.　　float　:1.2345678252014001e+021


**解析如下：**

------

解析：
第7行代码 `cout << setprecision(18) << "float :" << f << endl;` 中，`f` 是一个 `float` 类型的变量，其值为 `12.3456789012345678901E20`。由于 `float` 类型的精度限制，无法精确表示这么大的数，会进行舍入。

在大多数情况下，`float` 类型会以科学计数法的形式输出，且有效位数大约为7到8位。

选项中，B 和 D 都是比较接近的输出形式，但根据 `float` 的典型行为和精度，`D` 更符合实际情况，即 `1.2345678252014001e+021`。

正确答案是D。

答案：'{"22764":"D"}'

------

### 题目22765
问题：8.执行该程序，屏幕输出第三行为：
A.　double:12.345678901234568e+020
B.　double:1.2345678901234568e+021
C.　double:12.345678987284261e+020
D.　double:1.2345678987284261e+021


**解析如下：**

------

解析：
第9行代码 `cout << setprecision(18) << "double:" << d << endl;` 中，`d` 是一个 `double` 类型的变量，其值为 `12.3456789012345678901E20`。`double` 类型的精度较高，可以更精确地表示这个数。

由于 `setprecision(18)` 设置了输出精度为18位，`double` 类型会以科学计数法的形式输出，且有效位数大约为15到17位。

在选项中，B 和 D 都是比较接近的输出形式，但根据 `double` 的精度和科学计数法的表示方式，`B` 更符合实际情况，即 `1.2345678901234568e+021`。

正确答案是B。

答案：'{"22765":"B"}'

------

### 题目22766
问题：9.把程序第7行修改为cout　<<　setprecision(2)　<<　"float　:"　<<　f　<<　endl，执行该程序，屏幕输出第二行为：
A.　　float　:1.2e+021
B.　　float　:12e+020
C.　　float　:1.23e+021
D.　　float　:1.23e+020


**解析如下：**

------

解析：
将第7行修改为 `cout << setprecision(2) << "float :" << f << endl;` 后，`setprecision(2)` 设置了输出精度为2位。`f` 是一个 `float` 类型的变量，其值为 `12.3456789012345678901E20`。

由于精度设置为2位，输出结果会以科学计数法的形式显示，并且只保留两位有效数字。

在选项中，符合两位有效数字且以科学计数法表示的是 `1.2e+021`。

正确答案是A。

答案：'{"22766":"A"}'

------

