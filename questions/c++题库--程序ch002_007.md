## ch002_007
``` c++
1) #include<iostream>
2) #include <iomanip>
3) using namespace std;
4) int main(){
5)      cout<< setprecision(18) << "Real:"<<"12.3456789012345678901E20"<< endl;
6)    float f = 12.3456789012345678901E20;
7)    cout << setprecision(18) << "float :" << f << endl;
8)    double d = 12.3456789012345678901E20;
9)    cout << setprecision(18) << "double:" << d << endl;
10) }

```
### 题目22758
问题：1.关于函数setprecision的作用说法正确的是：
A.  没有用处
B.  设定输出宽度
C.  设定输出精度
D.  设定数据类型


**解析如下：**

------

解析：
setprecision是C++中的一个流操纵符，用于设定浮点数的输出精度，即小数点后的位数。它并不设定输出宽度或数据类型。

{'22758':'C'}

------

### 题目22759
问题：2.VS环境中float的有效位（含隐藏位）数是：
A. 6
B. 10
C. 8
D. 9


**解析如下：**

------

解析：
隐藏位是浮点数表示法中的一个概念，用于提高浮点数的精度。(自行了解)
**float不含隐藏位是7**,含隐藏位是8,vs是含隐藏位，故是8位。

{'22759':'C'}

------

### 题目22760
问题：3.VS环境中double的有效位数是：
A. 15
B.  16
C. 19
D.  20


**解析如下：**

------

解析：
VS中double的有效位数是16位

{'22760':'B'}

------

### 题目22761
问题：4.long double的有效位数是：
A. 15
B.  16
C. 19
D.  20


**解析如下：**

------

解析：
在VS环境中，long double类型的有效位数通常是64位，这相当于大约18到19个十进制数字。因此，long double的有效位数是19。

{'22761':'C'}

------

### 题目22762
问题：5.头文件iomanip的作用是：
A.包含输入输出函数
B.包含格式输入输出函数
C.包含数学函数
D.包含控制函数


**解析如下：**

------

解析：
头文件iomanip是C++标准库中的一个头文件，主要用于包含格式化输入输出操作的函数和流操纵符，如setprecision、setw等。

{'22762':'B'}

------

### 题目22763
问题：6.执行该程序，屏幕输出第一行为：
A. Real  :12.3456789012345678901
B. Real  :12.3456789012345678901E20
C. Real  :12.345678901234567890120
D. Real  :12.345678901234567890100


**解析如下：**

------

解析：
在程序中，第5行代码输出了一个字符串"Real:12.3456789012345678901E20"，并且使用了setprecision(18)来设定输出精度。由于字符串中的数值已经是完整的，setprecision不会影响字符串的输出格式。因此，屏幕输出的第一行将是字符串本身。

{'22763':'B'}

------

### 题目22764
问题：7. 执行该程序，屏幕输出第二行为：
A.  float :12.345678901234567e+020
B.  float :12.345678252014001e+020
C.  float :1.2345678901234567e+021
D.  float :1.2345678252014001e+021


**解析如下：**

------

解析：
系统提示：**float类型的正确位数为8位，也就是只保留8位有效数字位，其余的数字随机**
setprecision(n),功能：控制浮点数显示的有效数字个数(会自动四舍五入)
如果小数点前面不是0，这个n是指小数点后面有效数字个数；如果不是0，n是要包含小数点的以及有效数字
cout << setprecision(2) << "float :" << 1.5666 << endl;  //  1.6
cout << setprecision(2) << "float :" << 0.5666 << endl;  //  0.67

测试可能不全面，可自己测试并补充

{'22764':'D'}

------

### 题目22765
问题：8.执行该程序，屏幕输出第三行为：
A. double:12.345678901234568e+020
B. double:1.2345678901234568e+021
C. double:12.345678987284261e+020
D. double:1.2345678987284261e+021


**解析如下：**

------

解析：
题库提示：double类型的正确位数为16位，也就是只保留16位有效数字位，其余的数字随机。
跟上面类似，不太懂的话可以自行Search一下

{'22765':'B'}

------

### 题目22766
问题：9.把程序第7行修改为cout << setprecision(2) << "float :" << f << endl，执行该程序，屏幕输出第二行为：
A.  float :1.2e+021
B.  float :12e+020
C.  float :1.23e+021
D.  float :1.23e+020


**解析如下：**

------

解析：
在程序中，如果将第7行修改为`cout << setprecision(2) << "float :" << f << endl;`，setprecision(2)将设定输出精度为2位有效数字。由于float变量f的值非常大，输出结果将以科学计数法表示，并且只保留2位有效数字。

根据float类型的精度，输出结果将是1.2e+021。

{'22766':'A'}

------

