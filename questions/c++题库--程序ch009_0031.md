## ch009_0031
``` c++
1)　　#include　<iostream>
2)　　using　namespace　std;
3)　　struct　Employee　{　//名为Enployee的结构声明
4)　　　　long　code;
5)　　　　char　name[20];
6)　　　　float　salary;
7)　　};
8)　　const　int　plen　=　6;
9)　　Employee　person[plen]　=　{
10)　　　　{　1,　"jone",　339.0　},
11)　　　　{　2,　"david",　449.0　},
12)　　　　{　3,　"marit",　311.0　},
13)　　　　{　4,　"jasen",　623.0　},
14)　　　　{　5,　"peter",　400.0　},
15)　　　　{　6,　"yoke",　511.0　}
16)　　};
17)　　void　printEmployee(const　Employee　p);
18)　　void　main(){
19)　　　　Employee　temp,　*p;
20)　　　　for　(int　i　=　1;　i<plen;　i++){　　　　　　//排序
21)　　　　　　for　(p　=　person;　p　<=　person　+　plen　-　1　-　i;　p++){　
22)　　　　　　　　if　(p->salary　>(p　+　1)->salary)　{　//比较工资成员
23)　　　　　　　　　　temp　=　*p;　　　　　//结构变量的交换
24)　　　　　　　　　　*p　=　*(p　+　1);
25)　　　　　　　　　　*(p　+　1)　=　temp;
26)　　　　　　　　}
27)　　　　　　}
28)　　　　}
29)　　　　for　(int　k　=　0;　k　<　plen;　k++)　　　　//输出
30)　　　　　　printEmployee(person[k]);
31)　　　　system("pause");
32)　　}
33)　　void　printEmployee(const　Employee　p){
34)　　　　cout　<<　p.name　<<　"　　"　<<　p.code　<<　"　　"　<<　p.salary　<<　endl;
35)　　}

```
### 题目24321
问题：1.　　程序第9-16行的代码定义的标识符person，下述描述错误的是　（　　　　）：
A.　　person有6个数据元素
B.　　person存储在全局数据区中
C.　　person的数据成员值均为‘\\0’
D.　　person类型是Employee[]。


**解析如下：**

------

解析：程序第9-16行定义了一个名为`person`的数组，该数组有6个元素，每个元素都是`Employee`类型的结构体。选项A正确，因为数组`person`确实有6个数据元素。选项B错误，因为`person`是在函数外部定义的，所以它存储在全局数据区中。选项C错误，因为`person`的每个元素都被初始化了具体的值，而不是默认的`'\0'`。选项D正确，因为`person`的类型确实是`Employee[]`。

答案：{'24321':'C'}

------

### 题目24322
问题：2.　　在不考虑字节对齐的情况下，程序第9-16行的代码定义的数组变量person在内存中共分配（　　　　）个字节。
A.　　28
B.　　168
C.　　144
D.　　120


**解析如下：**

------

解析：每个`Employee`结构体包含一个`long`类型的`code`（通常占4字节），一个`char[20]`类型的`name`（占20字节），和一个`float`类型的`salary`（通常占4字节）。因此，每个`Employee`结构体占用的字节数为4 + 20 + 4 = 28字节。数组`person`有6个`Employee`元素，所以总共占用的字节数为6 * 28 = 168字节。

答案：{'24322':'B'}

------

### 题目24323
问题：3.　　逐语句调试程序，当程序第20行for循环中的表达式“i++”执行后，i的值为2，此时person[3]的成员code的值是（　　　　）。
A.　　3
B.　　4
C.　　5
D.　　6


**解析如下：**

------

解析：当程序第20行中的`i++`执行后，`i`的值为2，表示已经完成了第一次外层循环。第一次外层循环会对数组`person`进行一次冒泡排序，将工资最高的员工移动到数组的末尾。初始时，`person[3]`的`code`值为4（对应员工"jasen"）。经过第一次外层循环后，`person[3]`的`code`值变为5（对应员工"peter"），因为"peter"的工资比"jasen"低，所以"jasen"被移动到`person[4]`。

答案：{'24323':'C'}

------

### 题目24324
问题：4.　　程序第22行的表达式“p->salary　>(p　+　1)->salary”中有（　　　　）个运算符。
A.　　3
B.　　4
C.　　5
D.　　6


**解析如下：**

------

解析：表达式“p->salary >(p + 1)->salary”中包含以下运算符：
1. `->`：成员访问运算符
2. `>`：比较运算符
3. `+`：加法运算符
4. `->`：成员访问运算符

共有4个运算符。

答案：{'24324':'B'}

------

### 题目24325
问题：5.　　程序第25行的表达式“*(p　+　1)　=　temp”的值是（　　　　　）。
A.　　temp
B.　　p+1
C.　　p
D.　　*(p+1)


**解析如下：**

------

解析：表达式“*(p + 1) = temp”是一个赋值表达式，其作用是将`temp`的值赋给`*(p + 1)`所指向的内存位置。在C++中，赋值表达式的值是赋值操作左侧的值，即赋值后的`*(p + 1)`。

答案：{'24325':'D'}

------

### 题目24326
问题：6.　　逐语句调试程序，当程序第23行的代码第一次执行后，temp的成员code的值是（　　　　）。
A.　　1
B.　　2
C.　　3
D.　　4


**解析如下：**

------

解析：程序第23行的代码是`temp = *p;`，这是在冒泡排序中的第一次内层循环中执行的。初始时，数组`person`的元素按顺序是：
- `person[0]`：{1, "jone", 339.0}
- `person[1]`：{2, "david", 449.0}
- `person[2]`：{3, "marit", 311.0}
- `person[3]`：{4, "jasen", 623.0}
- `person[4]`：{5, "peter", 400.0}
- `person[5]`：{6, "yoke", 511.0}

第一次外层循环`i=1`时，内层循环`p`从`person`开始，比较`person[0]`和`person[1]`的`salary`。由于`339.0 < 449.0`，不交换。接着，`p`指向`person[1]`，比较`person[1]`和`person[2]`的`salary`。由于`449.0 > 311.0`，执行交换操作，即执行`temp = *p;`，此时`p`指向`person[1]`，所以`temp`的`code`值为2。

答案：{'24326':'B'}

------

### 题目24327
问题：7.　　逐语句调试程序，当程序第25行的代码第一次执行完后，person[1]的成员salary的值是（　　　　）。
A.　　339.0
B.　　449.0
C.　　311.0
D.　　623.0


**解析如下：**

------

解析：程序第25行的代码是`*(p + 1) = temp;`，这是在冒泡排序中的第一次内层循环中执行的交换操作的一部分。根据之前的分析，第一次执行交换操作时，`p`指向`person[1]`，`temp`被赋值为`person[1]`的值（即{2, "david", 449.0}），然后`person[1]`被赋值为`person[2]`的值（即{3, "marit", 311.0}），最后`person[2]`被赋值为`temp`的值（即{2, "david", 449.0}）。

因此，当第25行代码第一次执行完后，`person[1]`的`salary`值变为`person[2]`的`salary`值，即311.0。

答案：{'24327':'C'}

------

### 题目24328
问题：8.　　逐语句调试程序，当程序第25行的代码第一次执行完后，person[4]的成员salary的值是（　　　　）。
A.　　311.0
B.　　623.0
C.　　400.0
D.　　511.0


**解析如下：**

------

解析：程序第25行的代码是`*(p + 1) = temp;`，这是在冒泡排序中的交换操作的一部分。根据之前的分析，第一次执行交换操作时，`p`指向`person[1]`，涉及的是`person[1]`和`person[2]`的交换，与`person[4]`无关。

初始时，`person[4]`的`salary`值为400.0。第一次交换操作只影响了`person[1]`和`person[2]`，不会改变`person[4]`的值。因此，当第25行代码第一次执行完后，`person[4]`的`salary`值仍然是400.0。

答案：{'24328':'C'}

------

### 题目24329
问题：9.　　逐语句调试程序，当程序第20行for循环中的表达式“i++”执行后，i的值为2，此时person[4]的成员salary的值是（　　　　）。
A.　　339.0
B.　　449.0
C.　　511.0
D.　　623.0


**解析如下：**

------

解析：当程序第20行中的`i++`执行后，`i`的值为2，表示已经完成了第一次外层循环。第一次外层循环会对数组`person`进行一次冒泡排序，将工资最高的员工移动到数组的末尾。

初始时，数组`person`的`salary`值分别为：
- `person[0]`: 339.0
- `person[1]`: 449.0
- `person[2]`: 311.0
- `person[3]`: 623.0
- `person[4]`: 400.0
- `person[5]`: 511.0

经过第一次外层循环后，工资最高的员工（`person[3]`，salary为623.0）会被移动到`person[5]`的位置，其他员工的`salary`值会依次向前移动。因此，`person[4]`的`salary`值会变为初始时`person[5]`的`salary`值，即511.0。

答案：{'24329':'C'}

------

### 题目24330
问题：10.　　逐语句调试程序，当程序第20行for循环中的表达式“i++”执行后，i的值为2，此时temp的成员code的值是（　　　　）。
A.　　3
B.　　4
C.　　5
D.　　6


**解析如下：**

------

解析：当程序第20行中的`i++`执行后，`i`的值为2，表示已经完成了第一次外层循环。在第一次外层循环中，`temp`用于在冒泡排序过程中临时存储交换的`Employee`结构体。

在第一次外层循环中，`temp`会被多次赋值，最终它保存的是最后一次交换时的值。根据之前的分析，第一次外层循环的最后一次交换涉及`person[4]`和`person[5]`，即`temp`会被赋值为`person[4]`的值。

初始时，`person[4]`的`code`值为5。因此，当第一次外层循环结束时，`temp`的`code`值是5。

答案：{'24330':'C'}

------

### 题目24331
问题：11.　　当程序第29行的代码开始执行时，person[2]的成员name的值是（　　　　）。
A.　　“marit”
B.　　“jasen”
C.　　“peter”
D.　　“yoke”


**解析如下：**

------

解析：程序第29行的代码开始执行时，表示已经完成了所有的排序操作。根据冒泡排序的原理，数组`person`会按照`salary`从小到大的顺序排列。

初始时，数组`person`的`name`值分别为：
- `person[0]`: "jone"
- `person[1]`: "david"
- `person[2]`: "marit"
- `person[3]`: "jasen"
- `person[4]`: "peter"
- `person[5]`: "yoke"

经过冒泡排序后，`salary`最小的员工会移动到`person[0]`，`salary`最大的员工会移动到`person[5]`。根据初始数据和排序过程，最终`person[2]`的`name`值会是初始时`salary`第三小的员工的`name`。

初始时`salary`的顺序为：339.0, 449.0, 311.0, 623.0, 400.0, 511.0。排序后，`person[2]`的`name`值会是"peter"。

答案：{'24331':'C'}

------

