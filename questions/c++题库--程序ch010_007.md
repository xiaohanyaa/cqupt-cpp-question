## ch010_007
``` c++
1)　　#include　<iostream>
2)　　using　namespace　std;
3)　　int　main(){
4)　　　　　　unsigned　long　ip1　=　192,　ip2　=　68,　ip3　=　1,　ip4　=　6,　ip;
5)　　　　　　ip　=　(ip1　<<　24)　+　(ip2　<<　16)　+　(ip3　<<　8)　+　ip4;
6)　　　　　　cout　<<　"IP地址："　<<　ip1　<<　"."　<<　ip2　<<　"."　<<　ip3　<<　"."　<<　ip4　<<　endl;
7)　　　　　　unsigned　long　mask1　=　255,　mask2　=　255,　mask3　=　255,　mask4　=　0,　mask;
8)　　　　　　mask　=　(mask1　<<　24)　+　(mask2　<<　16)　+　(mask3　<<　8)　+　mask4;
9)　　　　　　cout　<<　"子网掩码："　<<　mask1　<<　"."　<<　mask2　<<　"."　<<　mask3　<<　"."　<<　mask4　<<　endl;
10)　　　　　　unsigned　long　int　net,　host;
11)　　　　　　net　=　ip&mask;
12)　　　　　　ip4　=　net　&　255;
13)　　　　　　ip3　=　(net　>>=　8)　&　255;
14)　　　　　　ip2　=　(net　>>=　8)　&　255;
15)　　　　　　ip1　=　(net　>>=　8)　&　255;
16)　　　　　　cout　<<　"网络地址："　<<　ip1　<<　"."　<<　ip2　<<　"."　<<　ip3　<<　"."　<<　ip4　<<　endl;
17)　　　　　　host　=　(mask　^　(-1))&ip;
18)　　　　　　ip4　=　host　&　255;
19)　　　　　　ip3　=　(host　>>=　8)　&　255;
20)　　　　　　ip2　=　(host　>>=　8)　&　255;
21)　　　　　　ip1　=　(host　>>=　8)　&　255;
22)　　　　　　cout　<<　"主机地址："　<<　ip1　<<　"."　<<　ip2　<<　"."　<<　ip3　<<　"."　<<　ip4　<<　endl;
23)　　　　　　system("pause");
24)　　}

```
### 题目24086
问题：54.　　代码第4行中，unsigned　long的存储空间大小为：
A.　　2字节
B.　　4字节
C.　　8字节
D.　　16字节


**解析如下：**

------

解析：
在C++中，`unsigned long`的存储空间大小取决于编译器和平台。在大多数现代平台上，`unsigned long`通常是4字节（32位）。然而，在某些64位系统上，它可能是8字节（64位）。为了确定具体大小，可以使用`sizeof`运算符。

代码示例：
```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Size of unsigned long: " << sizeof(unsigned long) << " bytes" << endl;
    return 0;
}
```

运行结果（在大多数32位和64位系统上）：
```
Size of unsigned long: 4 bytes
```

因此，正确答案是B。

{'24086':'B'}

------

### 题目24087
问题：55.　　执行完代码第4行，变量ip1在内存中存储的二进制低8位是：
A.　　01100000
B.　　00110000
C.　　00011000
D.　　11000000


**解析如下：**

------

解析：
代码第4行定义了变量`ip1`并赋值为192。我们需要将192转换为二进制形式。

192的二级制表示为：
```
192 = 11000000
```

因此，变量`ip1`在内存中存储的二进制低8位是`11000000`。

正确答案是D。

{'24087':'D'}

------

### 题目24088
问题：56.　　执行完代码第4行，变量ip2在内存中存储的二进制低8位是：
A.　　01000100　
B.　　00100010
C.　　00010001
D.　　01000101


**解析如下：**

------

解析：
代码第4行定义了变量`ip2`并赋值为68。我们需要将68转换为二进制形式。

68的二进制表示为：
```
68 = 01000100
```

因此，变量`ip2`在内存中存储的二进制低8位是`01000100`。

正确答案是A。

{'24088':'A'}

------

### 题目24089
问题：57.　　执行完代码第4行，变量ip3在内存中存储的二进制低8位是：
A.　　10000000
B.　　00000001
C.　　10000001
D.　　00000010


**解析如下：**

------

解析：
代码第4行定义了变量`ip3`并赋值为1。我们需要将1转换为二进制形式。

1的二进制表示为：
```
1 = 00000001
```

因此，变量`ip3`在内存中存储的二进制低8位是`00000001`。

正确答案是B。

{'24089':'B'}

------

### 题目24090
问题：58.　　执行完代码第4行，变量ip4在内存中存储的二进制低8位是：
A.　　00001110
B.　　00000111
C.　　00000110
D.　　00010110


**解析如下：**

------

解析：
代码第4行定义了变量`ip4`并赋值为6。我们需要将6转换为二进制形式。

6的二进制表示为：
```
6 = 00000110
```

因此，变量`ip4`在内存中存储的二进制低8位是`00000110`。

正确答案是C。

{'24090':'C'}

------

### 题目24091
问题：59.　　代码第5行中，关于表达式中变量ip1~ip4的说法不正确的是：
A.　　存储变量ip1~ip4，每个变量最多只需要8位
B.　　编译器为变量ip1分配的存储空间是64位
C.　　变量ip1的64位存储空间中，没有用到的位都存为0
D.　　变量ip的值为19216816


**解析如下：**

------

解析：
代码第5行中，变量`ip1`、`ip2`、`ip3`和`ip4`都是`unsigned long`类型，用于存储IP地址的各个段。

A. 存储变量`ip1`~`ip4`，每个变量最多只需要8位。这是正确的，因为每个IP段的最大值是255，8位二进制数可以表示0到255。

B. 编译器为变量`ip1`分配的存储空间是64位。这是不正确的，因为`unsigned long`在大多数平台上是32位（4字节），而不是64位。

C. 变量`ip1`的64位存储空间中，没有用到的位都存为0。这是不正确的，因为`ip1`本身不是64位，而是32位。

D. 变量`ip`的值为19216816。这是不正确的，因为根据代码第5行的计算，`ip`的值应该是将四个IP段拼接起来的结果，即`192.68.1.6`转换为32位整数，计算如下：
```
ip = (192 << 24) + (68 << 16) + (1 << 8) + 6
   = 3221225472 + 45056 + 256 + 6
   = 3221225986
```

因此，正确答案是B。

{'24091':'B'}

------

### 题目24092
问题：60.　　代码第7行中，变量mask1在内存中存储的二进制低8位是：
A.　　11111111
B.　　00001111
C.　　11110000
D.　　00000000


**解析如下：**

------

解析：
代码第7行定义了变量`mask1`并赋值为255。我们需要将255转换为二进制形式。

255的二进制表示为：
```
255 = 11111111
```

因此，变量`mask1`在内存中存储的二进制低8位是`11111111`。

正确答案是A。

{'24092':'A'}

------

### 题目24093
问题：61.　　代码第8行中，变量mask在内存中存储的二进制低32位是：
A.　　00001111111111111111111111110000
B.　　11111111111111111111111100000000
C.　　11111111111111111111111111110000
D.　　00001111111111111111111100000000


**解析如下：**

------

解析：
代码第8行计算变量`mask`的值，通过将`mask1`、`mask2`、`mask3`和`mask4`进行位运算拼接。

各变量的值及其二进制表示为：
```
mask1 = 255 = 11111111
mask2 = 255 = 11111111
mask3 = 255 = 11111111
mask4 = 0   = 00000000
```

计算过程如下：
```
mask = (mask1 << 24) + (mask2 << 16) + (mask3 << 8) + mask4
      = (11111111 << 24) + (11111111 << 16) + (11111111 << 8) + 00000000
      = 11111111000000000000000000000000 + 00000000111111110000000000000000 + 00000000000000001111111100000000 + 00000000000000000000000000000000
      = 11111111111111111111111100000000
```

因此，变量`mask`在内存中存储的二进制低32位是`11111111111111111111111100000000`。

正确答案是B。

{'24093':'B'}

------

### 题目24094
问题：62.　　代码第11行中，按位看，变量net的取值中右边多少位值为0：
A.　　4位
B.　　8位
C.　　16位
D.　　32位


**解析如下：**

------

解析：
代码第11行计算变量`net`的值，通过将`ip`和`mask`进行按位与操作。

根据之前的计算：
```
ip = 3221225986 = 11000000101010000000000100000110
mask = 4294967040 = 11111111111111111111111100000000
```

按位与操作如下：
```
ip:   11000000101010000000000100000110
mask: 11111111111111111111111100000000
-----------------------------------
net:  11000000101010000000000100000000
```

从结果可以看出，`net`的右边8位全为0。

因此，变量`net`的取值中右边有8位值为0。

正确答案是B。

{'24094':'B'}

------

### 题目24095
问题：63.　　代码第12行中，net&255运算是将net取出了变量net二进制值的：
A.　　左8位
B.　　右8位
C.　　左16位
D.　　右16位


**解析如下：**

------

解析：
代码第12行中的运算`net & 255`是将`net`与255进行按位与操作。255的二进制表示为`11111111`。

按位与操作的目的是取出`net`的低8位（即右边8位），因为255的二进制表示在低8位全为1，其余位全为0。

例如，如果`net`的二进制表示为：
```
net:  11000000101010000000000100000000
255:  00000000000000000000000011111111
-----------------------------------
result:00000000000000000000000000000000
```

从上面的示例可以看出，结果只保留了`net`的右8位。

因此，`net & 255`运算是将`net`取出了变量`net`二进制值的右8位。

正确答案是B。

{'24095':'B'}

------

### 题目24096
问题：64.　　代码第13行中，关于表达式(net　>>=　8)　&　255，说法不正确的是：
A.　　执行该表达式，变量net的值向右移8位
B.　　执行该表达式，变量net的值将更新
C.　　>>=与>>是等价的操作
D.　　变量net更新后的值，右8位将被取出，用于给变量ip3赋值


**解析如下：**

------

解析：
代码第13行中的表达式`(net >>= 8) & 255`包含了两个操作：

1. `net >>= 8`：将`net`的值向右移8位，并且更新`net`的值。
2. `& 255`：将右移后的`net`值与255进行按位与操作，取出低8位。

具体分析各选项：

A. 执行该表达式，变量`net`的值向右移8位。这是正确的。

B. 执行该表达式，变量`net`的值将更新。这是正确的，因为`>>=`是右移并赋值操作。

C. `>>=`与`>>`是等价的操作。这是不正确的。`>>=`是右移并赋值操作，而`>>`只是右移操作，不更新原变量的值。

D. 变量`net`更新后的值，右8位将被取出，用于给变量`ip3`赋值。这是正确的。

因此，不正确的说法是C。

正确答案是C。

{'24096':'C'}

------

### 题目24097
问题：65.　　代码17行中，-1在内存中存为二进制，各位取值为：
A.　　全为1
B.　　全为0
C.　　随机值
D.　　Null


**解析如下：**

------

解析：
在C++中，整数`-1`在内存中通常使用补码表示。对于32位整数，`-1`的补码表示为所有位都为1。

具体来说，`-1`的二进制表示如下：
```
-1 = 11111111111111111111111111111111 (32位整数)
```

这是因为补码的计算方式是将正数的二进制取反再加1。对于`1`来说，二进制表示为`00000000000000000000000000000001`，取反后为`11111111111111111111111111111110`，再加1即为`11111111111111111111111111111111`。

因此，`-1`在内存中存为二进制，各位取值为全为1。

正确答案是A。

{'24097':'A'}

------

### 题目24098
问题：66.　　代码17行中，表达式(mask　^　(-1))&ip的操作符运算顺序为：
A.　　按位逻辑与、按位逻辑异或
B.　　按位逻辑异或、按位逻辑与
C.　　按位逻辑或、按位逻辑异或
D.　　按位逻辑异或、按位逻辑或


**解析如下：**

------

解析：
代码第17行中的表达式是`(mask ^ (-1)) & ip`。我们需要确定操作符的运算顺序。

根据C++的运算符优先级规则：
- 按位逻辑异或（`^`）的优先级高于按位逻辑与（`&`）。

因此，表达式的运算顺序是：
1. 先进行按位逻辑异或操作：`mask ^ (-1)`
2. 然后用结果进行按位逻辑与操作：`结果 & ip`

具体来说：
```
(mask ^ (-1)) & ip
```
先计算`mask ^ (-1)`，再用这个结果与`ip`进行按位逻辑与操作。

因此，操作符的运算顺序为按位逻辑异或、按位逻辑与。

正确答案是B。

{'24098':'B'}

------

