## ch010_007
``` c++
1)  #include <iostream>
2)  using namespace std;
3)  int main(){
4)      unsigned long ip1 = 192, ip2 = 68, ip3 = 1, ip4 = 6, ip;
5)      ip = (ip1 << 24) + (ip2 << 16) + (ip3 << 8) + ip4;
6)      cout << "IP地址：" << ip1 << "." << ip2 << "." << ip3 << "." << ip4 << endl;
7)      unsigned long mask1 = 255, mask2 = 255, mask3 = 255, mask4 = 0, mask;
8)      mask = (mask1 << 24) + (mask2 << 16) + (mask3 << 8) + mask4;
9)      cout << "子网掩码：" << mask1 << "." << mask2 << "." << mask3 << "." << mask4 << endl;
10)      unsigned long int net, host;
11)      net = ip&mask;
12)      ip4 = net & 255;
13)      ip3 = (net >>= 8) & 255;
14)      ip2 = (net >>= 8) & 255;
15)      ip1 = (net >>= 8) & 255;
16)      cout << "网络地址：" << ip1 << "." << ip2 << "." << ip3 << "." << ip4 << endl;
17)      host = (mask ^ (-1))&ip;
18)      ip4 = host & 255;
19)      ip3 = (host >>= 8) & 255;
20)      ip2 = (host >>= 8) & 255;
21)      ip1 = (host >>= 8) & 255;
22)      cout << "主机地址：" << ip1 << "." << ip2 << "." << ip3 << "." << ip4 << endl;
23)      system("pause");
24)  }

```
### 题目24086
问题：54.  代码第4行中，unsigned long的存储空间大小为：
A.  2字节
B.  4字节
C.  8字节
D.  16字节


**解析如下：**

------

解析：
在C++中，64位机中，unsigned long分配的内存空间大小为8字节，即64位

{'24086':'C'}

------

### 题目24087
问题：55.  执行完代码第4行，变量ip1在内存中存储的二进制低8位是：
A.  01100000
B.  00110000
C.  00011000
D.  11000000


**解析如下：**

------

解析：
在代码第4行中，`ip1`被赋值为192。192的二进制表示为`11000000`。因此，`ip1`在内存中存储的二进制低8位是`11000000`。

{'24087':'D'}

------

### 题目24088
问题：56.  执行完代码第4行，变量ip2在内存中存储的二进制低8位是：
A.  01000100 
B.  00100010
C.  00010001
D.  01000101


**解析如下：**

------

解析：
在代码第4行中，`ip2`被赋值为68。68的二进制表示为`01000100`。因此，`ip2`在内存中存储的二进制低8位是`01000100`。

{'24088':'A'}

------

### 题目24089
问题：57.  执行完代码第4行，变量ip3在内存中存储的二进制低8位是：
A.  10000000
B.  00000001
C.  10000001
D.  00000010


**解析如下：**

------

解析：
在代码第4行中，`ip3`被赋值为1。1的二进制表示为`00000001`。因此，`ip3`在内存中存储的二进制低8位是`00000001`。

{'24089':'B'}

------

### 题目24090
问题：58.  执行完代码第4行，变量ip4在内存中存储的二进制低8位是：
A.  00001110
B.  00000111
C.  00000110
D.  00010110


**解析如下：**

------

解析：
在代码第4行中，`ip4`被赋值为6。6的二进制表示为`00000110`。因此，`ip4`在内存中存储的二进制低8位是`00000110`。

{'24090':'C'}

------

### 题目24091
问题：59.  代码第5行中，关于表达式中变量ip1~ip4的说法不正确的是：
A.  存储变量ip1~ip4，每个变量最多只需要8位
B.  编译器为变量ip1分配的存储空间是64位
C.  变量ip1的64位存储空间中，没有用到的位都存为0
D.  变量ip的值为19216816


**解析如下：**

------

解析：
在代码第5行中，`ip1`、`ip2`、`ip3`、`ip4`的值分别是192、68、1、6。每个变量的值都在0到255之间，因此每个变量最多只需要8位来存储。
long需要8字节；C正确；ip的值为3225682182

{'24091':'D'}

------

### 题目24092
问题：60.  代码第7行中，变量mask1在内存中存储的二进制低8位是：
A.  11111111
B.  00001111
C.  11110000
D.  00000000


**解析如下：**

------

解析：
在代码第7行中，`mask1`被赋值为255。255的二进制表示为`11111111`。因此，`mask1`在内存中存储的二进制低8位是`11111111`。

{'24092':'A'}

------

### 题目24093
问题：61.  代码第8行中，变量mask在内存中存储的二进制低32位是：
A.  00001111111111111111111111110000
B.  11111111111111111111111100000000
C.  11111111111111111111111111110000
D.  00001111111111111111111100000000


**解析如下：**

------

解析：
在代码第8行中，`mask`的计算方式是将`mask1`、`mask2`、`mask3`、`mask4`分别左移24位、16位、8位和0位，然后相加。`mask1`、`mask2`、`mask3`都是255（即二进制的`11111111`），`mask4`是0。因此，`mask`的二进制表示为：

```
mask1 << 24 = 11111111 00000000 00000000 00000000
mask2 << 16 = 00000000 11111111 00000000 00000000
mask3 << 8  = 00000000 00000000 11111111 00000000
mask4       = 00000000 00000000 00000000 00000000
```

将这些值相加得到：

```
mask = 11111111 11111111 11111111 00000000
```

因此，`mask`在内存中存储的二进制低32位是`11111111111111111111111100000000`。

{'24093':'B'}

------

### 题目24094
问题：62.  代码第11行中，按位看，变量net的取值中右边多少位值为0：
A.  4位
B.  8位
C.  16位
D.  32位


**解析如下：**

------

解析：
在代码第11行中，`net`的计算方式是`ip & mask`。`ip`的二进制表示为：

```
ip = 11000000 01000100 00000001 00000110
```

`mask`的二进制表示为：

```
mask = 11111111 11111111 11111111 00000000
```

按位与运算后，`net`的二进制表示为：

```
net = 11000000 01000100 00000001 00000000
```

可以看到，`net`的右边8位值为0。

{'24094':'B'}

------

### 题目24095
问题：63.  代码第12行中，net&255运算是将net取出了变量net二进制值的：
A.  左8位
B.  右8位
C.  左16位
D.  右16位


**解析如下：**

------

解析：
在代码第12行中，`net & 255`运算是将`net`的二进制值与`255`（即二进制的`11111111`）进行按位与运算。这个操作实际上是将`net`的二进制值的右8位取出，因为`255`的二进制表示为`11111111`，它只保留了`net`的低8位，其他位都被置为0。

{'24095':'B'}

------

### 题目24096
问题：64.  代码第13行中，关于表达式(net >>= 8) & 255，说法不正确的是：
A.  执行该表达式，变量net的值向右移8位
B.  执行该表达式，变量net的值将更新
C.  >>=与>>是等价的操作
D.  变量net更新后的值，右8位将被取出，用于给变量ip3赋值


**解析如下：**

------

解析：
在代码第13行中，表达式`(net >>= 8) & 255`的作用是将`net`的值向右移8位，然后将结果与`255`进行按位与运算。`>>=`是一个复合赋值运算符，它将右移操作的结果赋值给`net`，因此`net`的值会被更新。`>>=`与`>>`不是等价的操作，因为`>>=`会改变`net`的值，而`>>`不会。

{'24096':'C'}

------

### 题目24097
问题：65.  代码17行中，-1在内存中存为二进制，各位取值为：
A.  全为1
B.  全为0
C.  随机值
D.  Null


**解析如下：**

------

解析：
在代码第17行中，`-1`在内存中存储为二进制时，其各位取值为全为1。在二进制补码表示法中，`-1`的二进制表示是所有位都为1。

{'24097':'A'}

------

### 题目24098
问题：66.  代码17行中，表达式(mask ^ (-1))&ip的操作符运算顺序为：
A.  按位逻辑与、按位逻辑异或
B.  按位逻辑异或、按位逻辑与
C.  按位逻辑或、按位逻辑异或
D.  按位逻辑异或、按位逻辑或


**解析如下：**

------

解析：
在代码第17行中，表达式`(mask ^ (-1)) & ip`的操作符运算顺序是先进行按位逻辑异或（`^`），然后再进行按位逻辑与（`&`）。因此，正确的运算顺序是按位逻辑异或、按位逻辑与。

{'24098':'B'}

------

