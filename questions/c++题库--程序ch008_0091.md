## ch008_0091
``` c++
1)　　#include　<iostream>
2)　　using　namespace　std;
3)　　void　strCopy(char*　dest,　char*　source)
4)　　{
5)　　　　while　(*dest++　=　*source++);
6)　　}
7)　　void　strAdd(char*　dest,　char*　source)
8)　　{
9)　　　　while　(*dest){　　//移到结束标志
10)　　　　　　dest++;
11)　　　　}
12)　　　　while　(*source){
13)　　　　　　*dest　=　*source;//复制当前字符
14)　　　　　　dest++;
15)　　　　　　source++;
16)　　　　};
17)　　　　*dest　=　'\\0';//设置结束标志
18)　　}
19)　　void　main(){
20)　　　　char　a[20]　=　"copy　string.";
21)　　　　//字符串加法
22)　　　　char　c[30]　=　"computer　";
23)　　　　strAdd(c,　a);
24)　　　　cout　<<　"连接后的字符串长度:"　<<　strlen(c)　+　strlen("1234567890123")　<<　endl;
25)　　　　strAdd(c,　"1234567890123");
26)　　　　cout　<<　c　<<　endl;
27)　　　　system("pause");
28)　　}

```
### 题目24140
问题：1.　　删除该程序的3-6行，下列描述正确的是（　　　　）：
A.　　程序编译无法通过。
B.　　程序编译可以通过，链接时报错。
C.　　程序编译可以通过并能够运行。
D.　　无法判断。


**解析如下：**

------

解析：删除3-6行后，`strCopy`函数被移除，但该函数在`main`函数中并未被调用。程序的主要逻辑依赖于`strAdd`函数，该函数仍然存在且完整。因此，程序编译可以通过并能够运行。

答案：`{'24140':'C'}`

------

### 题目24141
问题：2.　　程序第24行执行后，屏幕输出结果为(　　)：
A.　　连接后的字符串长度:34
B.　　连接后的字符串长度:331234567890123
C.　　连接后的字符串长度:33
D.　　连接后的字符串长度:1234567890123


**解析如下：**

------

解析：程序第24行执行时，`c`数组中的字符串为"computer copy string."，其长度为20。`strlen("1234567890123")`的长度为13。因此，输出结果为20 + 13 = 33。

答案：`{'24141':'C'}`

------

### 题目24142
问题：3.　　程序第20行执行后，a[10]的值为(　　)：
A.　　‘n’
B.　　‘g’
C.　　‘\\0’
D.　　‘.’


**解析如下：**

------

解析：程序第20行定义了字符数组`a`并初始化为"copy string."。在这个字符串中，第10个字符（索引为9）是'g'，第11个字符（索引为10）是'.'。

答案：`{'24142':'D'}`

------

### 题目24143
问题：4.　　程序第20行执行后，a[13]的值为(　　)：
A.　　‘0’
B.　　随机值
C.　　‘\\0’
D.　　‘.’


**解析如下：**

------

解析：程序第20行定义了字符数组`a`并初始化为"copy string."。这个字符串的实际长度为12个字符，包括结尾的空字符'\\0'。因此，`a[13]`超出了初始化的范围，其值未定义，可能是随机值。

答案：`{'24143':'B'}`

------

### 题目24144
问题：5.　　程序第23行执行后，数组c存储的内容为(　　)：
A.　　“copy　string.”
B.　　“computer”
C.　　“copy　string.computer　”
D.　　“computer　copy　string.”


**解析如下：**

------

解析：程序第23行调用了`strAdd`函数，将数组`a`的内容追加到数组`c`的末尾。初始时，`c`数组的内容为"computer "，`a`数组的内容为"copy string."。执行`strAdd`后，`c`数组的内容变为"computer copy string."。

答案：`{'24144':'D'}`

------

### 题目24145
问题：6.　　程序第25行执行后，数组元素c[24]的值为(　　)：
A.　　‘3’
B.　　‘4’
C.　　‘5’
D.　　‘\\0’


**解析如下：**

------

解析：程序第25行调用了`strAdd`函数，将字符串"1234567890123"追加到数组`c`的末尾。在第23行执行后，`c`数组的内容为"computer copy string."，长度为20。追加"1234567890123"后，`c`数组的内容变为"computer copy string.1234567890123"。因此，`c[24]`是追加字符串中的第4个字符，即'4'。

答案：`{'24145':'B'}`

------

### 题目24146
问题：7.　　函数strAdd()第一次被调用时，当程序执行到第12行时，*dest的值为(　　)：
A.　　‘c’
B.　　‘　’
C.　　‘0’
D.　　‘\\0’


**解析如下：**

------

解析：函数`strAdd`第一次被调用时，`dest`指向`c`数组的末尾，即"computer "的空字符'\\0'。在第9-11行的循环中，`dest`会移动到字符串的结尾标志'\\0'。因此，当程序执行到第12行时，`*dest`的值为'\\0'。

答案：`{'24146':'D'}`

------

### 题目24147
问题：8.　　函数strAdd()第一次被调用时，当程序执行到第13行时，*source的值为(　　)：
A.　　‘c’
B.　　‘　’
C.　　‘0’
D.　　‘\\0’


**解析如下：**

------

解析：函数`strAdd`第一次被调用时，`source`指向`a`数组的开头，即"copy string."的第一个字符'c'。在第9-11行的循环中，`dest`移动到字符串`c`的结尾标志'\\0'，而`source`未动。因此，当程序执行到第13行时，`*source`的值为'c'。

答案：`{'24147':'A'}`

------

### 题目24148
问题：9.　　函数strAdd()第一次被调用时，当程序执行完第14行后，*dest的值为(　　)：
A.　　‘c’
B.　　‘　’
C.　　‘0’
D.　　‘\\0’


**解析如下：**

------

解析：函数`strAdd`第一次被调用时，`dest`初始指向`c`数组的结尾标志'\\0'。在第13行，`*dest`被赋值为`*source`，即'c'。在第14行，`dest`指针递增，指向下一个位置。因此，执行完第14行后，`*dest`的值是未定义的，但在下一次循环中会被赋值为`source`的下一个字符。

答案：`{'24148':'B'}`

------

### 题目24149
问题：10.　　函数strAdd()第一次被调用时，当程序执行完第13行后，如果立即执行语句“cout<<c<<endl；”，则屏幕输出结果为(　　)：
A.　　computer　copy　string.
B.　　computer　c
C.　　computer　copy　
D.　　computer　


**解析如下：**

------

解析：函数`strAdd`第一次被调用时，`dest`初始指向`c`数组的结尾标志'\\0'，`source`指向`a`数组的开头'c'。在第13行，`*dest`被赋值为`*source`，即'c'。此时，`c`数组的内容变为"computer c"，但未设置新的结尾标志'\\0'。如果立即执行`cout<<c<<endl;`，输出会从`c`数组的开头一直读取到遇到下一个'\\0'，但由于未设置新的结尾标志，输出可能会包含未定义的字符，直到遇到内存中的某个'\\0'。

然而，根据题目的选项，最合理的答案是输出到第一个'c'，即"computer c"。

答案：`{'24149':'B'}`

------

### 题目24150
问题：11.　　如果把程序第12行~16行，使用语句“while　(*dest++　=　*source++);”替换，则下述描述正确的是(　　)：
A.　　替换后的程序代码，无法实现原有功能。
B.　　替换后的程序代码，在编译时出错。
C.　　替换后的程序代码，可以实现原有功能。　
D.　　以上描述都有可能。


**解析如下：**

------

解析：将程序第12行到16行替换为`while (*dest++ = *source++);`，这个新语句的作用是将`source`指向的字符串复制到`dest`指向的位置，直到遇到`source`中的'\\0'。这个替换后的代码与原代码的功能相同，都是将`source`字符串追加到`dest`字符串的末尾。

答案：`{'24150':'C'}`

------

### 题目24151
问题：12.　　如果把程序第12行~16行，与下述代码等价的是(　　)：
A.　　“while　(*(dest++)　=　*(source++));”。
B.　　“while　(*dest++　==　*source++);”。
C.　　“while　(*dest++　=　*source++)”。　
D.　　“while　((*dest)++　=　(*source)++);”。　


**解析如下：**

------

解析：程序第12行到16行的代码功能是将`source`指向的字符串复制到`dest`指向的位置，直到遇到`source`中的'\\0'。选项C中的代码`while (*dest++ = *source++);`与原代码功能完全一致，都是通过赋值操作将`source`的字符逐个复制到`dest`，并在遇到'\\0'时结束循环。

选项A中的`while (*(dest++) = *(source++));`与C等价，因为`*(dest++)`和`*(source++)`的括号不影响运算顺序。

选项B中的`while (*dest++ == *source++);`是进行比较操作，不符合复制字符串的需求。

选项D中的`while ((*dest)++ = (*source)++);`会导致指针递增而不是指向下一个字符，不符合需求。

因此，最准确的等价代码是选项C。

答案：`{'24151':'C'}`

------

### 题目24152
问题：13.　　如下与程序第5行代码等价的是(　　)：
A.　　“while　(*dest++　==　*source++);”
B.　　“while　((*dest)++　==　*source++)”
C.　　“while　((*dest)++　=　(*source)++);”　
D.　　“while　(*(dest++)　=　*(source++));”


**解析如下：**

------

解析：程序第5行的代码`while (*dest++ = *source++);`的作用是将`source`指向的字符串复制到`dest`指向的位置，直到遇到`source`中的'\\0'。这个语句利用了赋值操作`*dest++ = *source++`，在复制每个字符的同时递增指针。

选项A中的`while (*dest++ == *source++);`是进行比较操作，不符合复制字符串的需求。

选项B中的`while ((*dest)++ == *source++);`同样是比较操作，且递增的是指针指向的值而不是指针本身，不符合需求。

选项C中的`while ((*dest)++ = (*source)++);`会导致指针指向的值递增，而不是指针本身递增，不符合需求。

选项D中的`while (*(dest++) = *(source++));`与原代码功能完全一致，都是通过赋值操作将`source`的字符逐个复制到`dest`，并在遇到'\\0'时结束循环。

因此，最准确的等价代码是选项D。

答案：`{'24152':'D'}`

------

### 题目24153
问题：14.　　关于表达式“*dest++　=　*source++”，如下描述最正确的是(　　)：
A.　　表达式的值是*dest　。
B.　　表达式的值是dest
C.　　表达式的值是source
D.　　表达式的值是*source


**解析如下：**

------

解析：表达式`*dest++ = *source++`的执行过程如下：
1. `*dest`取得`dest`指向的当前值。
2. `*source`取得`source`指向的当前值。
3. 将`*source`的值赋给`*dest`。
4. `dest`递增，指向下一个位置。
5. `source`递增，指向下一个位置。

整个表达式的值是赋值操作的结果，即`*dest`被赋值后的值。

因此，最正确的描述是选项A。

答案：`{'24153':'A'}`

------

### 题目24154
问题：15.　　如果把第7行代码修改为“void　strAdd(const　char*　dest,　const　char*　source)”，如下描述最正确的是(　　)：
A.　　程序编译无法通过。
B.　　程序编译可以通过，链接时报错。
C.　　程序编译可以通过并能够运行。
D.　　无法判断。


**解析如下：**

------

解析：将第7行代码修改为`void strAdd(const char* dest, const char* source)`后，`dest`和`source`参数被声明为`const char*`，表示它们指向的字符内容不能被修改。

在`strAdd`函数的实现中，需要对`dest`指向的内存进行修改（追加字符串），但由于`dest`被声明为`const`，编译器会报错，不允许修改`const`指向的内容。

因此，程序编译无法通过。

答案：`{'24154':'A'}`

------

### 题目24155
问题：16.　　如果把第7行代码修改为“void　strAdd(char*　dest,　const　char*　source)”，如下描述最正确的是(　　)：
A.　　程序编译无法通过。
B.　　程序编译可以通过，链接时报错。
C.　　程序编译可以通过并能够运行。
D.　　无法判断。


**解析如下：**

------

解析：将第7行代码修改为`void strAdd(char* dest, const char* source)`后，`dest`参数是`char*`，表示可以修改`dest`指向的内存内容，而`source`参数是`const char*`，表示不能修改`source`指向的内存内容。

在`strAdd`函数的实现中，确实需要修改`dest`指向的内存（追加字符串），而不需要修改`source`指向的内存（只需读取）。因此，这种修改是合理的，程序可以编译通过并正常运行。

答案：`{'24155':'C'}`

------

### 题目24156
问题：17.　　函数strAdd()第2次被调用时，当程序执行完第13行后，如果立即执行语句“cout<<c<<endl；”，则屏幕输出结果为(　　)：
A.　　computer　copy　string.
B.　　computer　c
C.　　computer　copy　string.1　
D.　　1　


**解析如下：**

------

解析：函数`strAdd`第二次被调用时，`dest`指向`c`数组的末尾，即"computer copy string."的结尾，`source`指向字符串"1234567890123"的开头。

在第13行，`*dest`被赋值为`*source`，即'1'。此时，`c`数组的内容变为"computer copy string.1"，但未设置新的结尾标志'\\0'。

如果立即执行`cout<<c<<endl;`，输出会从`c`数组的开头一直读取到遇到下一个'\\0'，输出结果为"computer copy string.1"。

答案：`{'24156':'C'}`

------

### 题目24157
问题：
18.　　函数strAdd()第2次被调用时，当程序执行完第14行后，*dest的值为(　　)：
A.　　‘c’
B.　　‘　’
C.　　‘0’
D.　　‘\\0’


**解析如下：**

------

解析：函数`strAdd`第二次被调用时，`dest`指向`c`数组的末尾，即"computer copy string."的结尾，`source`指向字符串"1234567890123"的开头。

在第13行，`*dest`被赋值为`*source`，即'1'。在第14行，`dest`指针递增，指向下一个位置。

因此，执行完第14行后，`*dest`的值是未定义的，但在下一次循环中会被赋值为`source`的下一个字符。

根据选项，最合理的答案是空格字符' '（即B选项），因为在字符串"computer copy string."的末尾追加字符后，下一个位置可能是未初始化的内存，通常表现为空格或随机值。

答案：`{'24157':'B'}`

------

### 题目24158
问题：19.　　函数strAdd()第2次被调用时，当程序执行完第13行后，*dest的值为(　　)：
A.　　‘c’
B.　　‘1’
C.　　‘　’
D.　　‘0’


**解析如下：**

------

解析：函数`strAdd`第二次被调用时，`dest`指向`c`数组的末尾，即"computer copy string."的结尾，`source`指向字符串"1234567890123"的开头。

在第13行，`*dest`被赋值为`*source`，即'1'。

因此，执行完第13行后，`*dest`的值为'1'。

答案：`{'24158':'B'}`

------

### 题目24159
问题：20.　　逐过程调试语句，程序第26行执行后，在屏幕上输出结果为(　　)：
A.　　computer　copy　string.
B.　　computer　copy　string.123456789
C.　　computer　copy　string.1234567890123
D.　　运行报错


**解析如下：**

------

解析：程序第26行执行`cout << c << endl;`，此时`c`数组已经通过两次调用`strAdd`函数，分别追加了字符串"a"和"1234567890123"。因此，`c`数组的内容是"computer copy string.1234567890123"。

答案：`{'24159':'C'}`

------

