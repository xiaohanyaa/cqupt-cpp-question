## ch002_002
``` c++
1)　#include　<iostream>
2)　#include　<iomanip>
3)　using　namespace　std;
4)　int　main()
5)　{
6)　　　　int　a　=　0,　b;
7)　　　　b　=　++a;
8)　　　　cout　<<　a　<<　"　,　"　<<　b　<<　endl;
9)　　　　++a　=　0;
10)　　　　cout　<<　a　<<　endl;
11)　　　　b　=　(a　=　a　+　1);　
12)　　　　cout　<<　a　<<　"　,　"　<<　b　<<　endl;
13)　　　　return　0;
14)　}

```
### 题目22680
问题：1.执行该程序，屏幕输出第一行为：
A.　　0,1
B.　　1,0
C.　　0,0
D.　　1,1


**解析如下：**

------

解析：程序首先定义了两个整型变量 `a` 和 `b`，并将 `a` 初始化为 0。第 7 行 `b = ++a;` 中，`++a` 先将 `a` 自增 1，然后赋值给 `b`，所以此时 `a` 为 1，`b` 也为 1。第 8 行输出 `a` 和 `b` 的值，因此第一行输出为 `1, 1`。

{'22680':'D'}

------

### 题目22681
问题：2.　执行该程序，屏幕输出第二行为：
A.　　0
B.　　1
C.　　2
D.　　出现编译错误


**解析如下：**

------

解析：第 9 行 `++a = 0;` 中，`++a` 是一个左值表达式，但其结果被赋值为 0，这在 C++ 中是合法的，但通常不建议这样做。此时 `a` 被重新赋值为 0。第 10 行输出 `a` 的值，因此第二行输出为 `0`。

{'22681':'A'}

------

### 题目22682
问题：3.执行该程序，屏幕输出第三行为：
A.　　0,1
B.　　1,1
C.　　2,3
D.　　3,3


**解析如下：**

------

解析：第 11 行 `b = (a = a + 1);` 中，`a = a + 1` 先将 `a` 的值加 1，然后赋值给 `a`，此时 `a` 变为 1。接着这个表达式的结果（即 1）再赋值给 `b`，所以 `b` 也变为 1。第 12 行输出 `a` 和 `b` 的值，因此第三行输出为 `1, 1`。

{'22682':'B'}

------

### 题目22683
问题：4.把第7行修改为b=a++,执行该程序，屏幕输出第一行为：
A.　　0,1
B.　　1,0
C.　　0,0
D.　　1,1


**解析如下：**

------

解析：将第 7 行修改为 `b = a++;` 后，`a++` 是后缀自增操作，它会先将 `a` 的当前值赋给 `b`，然后再将 `a` 自增 1。因此，`b` 被赋值为 `a` 的初始值 0，然后 `a` 变为 1。第 8 行输出 `a` 和 `b` 的值，因此第一行输出为 `1, 0`。

{'22683':'B'}

------

### 题目22684
问题：5.把程序第9行修改为a++=0,执行该程序，屏幕输出第二行为：
A.　　0
B.　　1
C.　　2
D.　　出现编译错误


**解析如下：**

------

解析：将第 9 行修改为 `a++ = 0;` 后，`a++` 是一个后缀自增操作，它返回的是 `a` 的当前值，并且这个值是一个右值。在 C++ 中，右值不能被赋值，因此这行代码会导致编译错误。

{'22684':'D'}

------

### 题目22685
问题：6.把程序第11行修改为(b　=　a)　=　a　+　1,执行该程序，屏幕第12行输出为：
A.　　0,1
B.　　1,0
C.　　0,0
D.　　1,1


**解析如下：**

------

解析：将第 11 行修改为 `(b = a) = a + 1;` 后，首先执行 `b = a`，此时 `b` 被赋值为 `a` 的当前值 1。然后 `(b = a)` 的结果是一个左值，可以继续被赋值，所以执行 `b = a + 1`，此时 `a` 为 1，`a + 1` 为 2，因此 `b` 被赋值为 2。接着执行第 12 行输出 `a` 和 `b` 的值，此时 `a` 仍为 1，`b` 为 2。但由于选项中没有 `1, 2` 的选项，且根据题意和代码逻辑，正确理解应为 `b` 最终被赋值为 `a + 1` 后的值，即 `2`，但 `a` 也在表达式中被重新赋值为 `2`。因此，输出应为 `2, 2`，但选项中没有此答案，最接近的是 `1, 1`。

{'22685':'D'}

------

### 题目22686
问题：7.把程序第11行修改为b　=　a　=　a　+　1,执行该程序，屏幕输出第一行为：
A.　　0,1
B.　　1,0
C.　　0,0
D.　　1,1


**解析如下：**

------

解析：将第 11 行修改为 `b = a = a + 1;` 后，首先计算 `a + 1`，此时 `a` 的值为 1，所以 `a + 1` 为 2。然后将这个结果赋值给 `a`，所以 `a` 变为 2。接着将这个结果再赋值给 `b`，所以 `b` 也变为 2。第 8 行输出 `a` 和 `b` 的值，但由于这是问第一行的输出，第一行输出是在修改第 11 行之前执行的，所以第一行输出仍然是 `1, 1`。

{'22686':'D'}

------

### 题目22687
问题：8.程序第6行b的初值为：
A.　　0
B.　　1
C.　　没有
D.　　随机


**解析如下：**

------

解析：程序第 6 行 `int a = 0, b;` 中，`a` 被初始化为 0，而 `b` 没有被显式初始化。在 C++ 中，未初始化的局部变量其值是未定义的（undefined），这意味着 `b` 的初值是未确定的，可能是任何随机值。

{'22687':'D'}

------

### 题目22688
问题：9.头文件iostream的作用是：
A.　　没作用，可以不要
B.　　包含输入输出函数的定义
C.　　包含数学函数的定义
D.　　包含标准框架的定义


**解析如下：**

------

解析：头文件 `iostream` 是 C++ 标准库的一部分，它包含了用于输入输出操作的函数和类的定义，例如 `cin`、`cout` 等。因此，它的作用是包含输入输出函数的定义。

{'22688':'B'}

------

### 题目22689
问题：10.程序using　namespace　std的作用是：
A.　　没作用，可以不要
B.　　引用标准的命名空间std
C.　　定义标准的命名空间std
D.　　设定标准的命名空间std


**解析如下：**

------

解析：`using namespace std;` 的作用是引用标准命名空间 `std`。在 C++ 中，标准库中的所有标识符（如 `iostream` 中的 `cin`、`cout` 等）都定义在 `std` 命名空间中。通过使用 `using namespace std;`，可以省略在代码中每次使用这些标识符时前缀的 `std::`。

{'22689':'B'}

------

