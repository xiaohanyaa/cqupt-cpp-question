## ch009_0021
``` c++
1)　　#include　<iostream>
2)　　using　namespace　std;
3)　　struct　Employee　{　　
4)　　　　long　code;
5)　　　　char　name[20];
6)　　　　float　salary;
7)　　};
8)　　const　int　plen　=　6;
9)　　Employee　person[plen]　=　{
10)　　　　{　1,　"jone",　339.0　},
11)　　　　{　2,　"david",　449.0　},
12)　　　　{　3,　"marit",　311.0　},
13)　　　　{　4,　"jasen",　623.0　},
14)　　　　{　5,　"peter",　400.0　},
15)　　　　{　6,　"yoke",　511.0　}
16)　　};
17)　　void　printEmployee(const　Employee　p);
18)　　void　main(){
19)　　　　Employee　temp;
20)　　　　for　(int　i　=　1;　i　<　plen;　i++){　　　//排序
21)　　　　　　　　for　(int　j　=　0;　j　<=　plen　-　1　-　i;　j++){　　　　//一轮比较
22)　　　　　　　　if　(person[j].salary>person[j　+　1].salary)　{　
23)　　　　　　　　　　　　　　　　temp　=　person[j];　　　　　//结构变量的交换
24)　　　　　　　　person[j]　=　person[j　+　1];
25)　　　　　　　　person[j　+　1]　=　temp;
26)　　　　　　　　}
27)　　　　　　　　}
28)　　　　}
29)　　　　for　(int　k　=　0;　k　<plen;　k++)　　　　//输出
30)　　　　　　　　printEmployee(person[k]);
31)　　　　system("pause");
32)　　}
33)　　void　printEmployee(const　Employee　p){
34)　　　　　cout　<<　p.name　<<　"　　"<<　p.code　<<　"　　"<<　p.salary　<<　endl;
35)　　}

```
### 题目24310
问题：1.　　程序第3-7行的代码，严格来讲是一个结构体（　　　　）：
A.　　类型声明
B.　　类型定义
C.　　类型解释
D.　　函数定义


**解析如下：**

------

解析：第3-7行的代码定义了一个名为`Employee`的结构体，这属于类型定义。

答案：{'24310':'B'}

------

### 题目24311
问题：2.　　程序第9-16行的代码定义的标识符person，下述描述错误的是　（　　　　）：
A.　　person有6个数据元素
B.　　person存储在全局数据区中
C.　　person的数据成员值均为‘\\0’
D.　　person类型是Employee[]。


**解析如下：**

------

解析：第9-16行的代码定义了一个`Employee`类型的数组`person`，包含6个元素，并且这些元素被初始化了具体的值，所以选项C描述错误。

答案：{'24311':'C'}

------

### 题目24312
问题：3.　　在不考虑字节对齐的情况下，程序第9-16行的代码定义的数组变量person在内存中共分配（　　　　）个字节。
A.　　28
B.　　168
C.　　144
D.　　120


**解析如下：**

------

解析：每个`Employee`结构体包含一个`long`（通常4字节）、一个`char[20]`（20字节）和一个`float`（通常4字节），总计28字节。数组`person`有6个元素，因此总字节数为6 * 28 = 168字节。

答案：{'24312':'B'}

------

### 题目24313
问题：4.　　程序第9-16行的代码段执行后，person[2]的成员salary的值是（　　　　）。
A.　　339.0
B.　　449.0
C.　　311.0
D.　　623.0


**解析如下：**

------

解析：第9-16行的代码段初始化了`person`数组，`person[2]`对应的是第13行的元素，其`salary`值为311.0。

答案：{'24313':'C'}

------

### 题目24314
问题：5.　　程序第9-16行的代码段执行后，person[5]的成员name的值是（　　　　）。
A.　　“marit”
B.　　“jasen”
C.　　“peter”
D.　　“yoke”


**解析如下：**

------

解析：第9-16行的代码段初始化了`person`数组，`person[5]`对应的是第15行的元素，其`name`值为"yoke"。

答案：{'24314':'D'}

------

### 题目24316
问题：7.　　逐语句调试程序，当程序第20行for循环中的表达式“i++”执行后，i的值为2，此时person[3]的成员code的值是（　　　　）。
A.　　3
B.　　4
C.　　5
D.　　6


**解析如下：**

------

解析：当`i++`执行后，`i`的值为2，此时第20行的`for`循环已经执行了一次。循环体内进行的是按`salary`升序排序。初始数组中`person[3]`的`code`值为4。经过一次循环后，`person[3]`的位置可能发生变化，但第一次循环只比较和交换了`person[0]`和`person[1]`，因此`person[3]`的`code`值仍为4。

答案：{'24316':'B'}

------

### 题目24317
问题：8.　　逐语句调试程序，当程序第20行for循环中的表达式“i++”执行后，i的值为2，此时person[4]的成员salary的值是（　　　　）。
A.　　339.0
B.　　449.0
C.　　511.0
D.　　623.0


**解析如下：**

------

解析：当`i++`执行后，`i`的值为2，此时第20行的`for`循环已经执行了一次。初始数组中`person[4]`的`salary`值为400.0。第一次循环中，`person[4]`未参与交换，因此其`salary`值仍为400.0。但由于选项中没有400.0，我们需要重新审视排序过程。

在第一次循环中，`person[0]`和`person[1]`可能会交换，`person[2]`和`person[3]`可能会交换，`person[3]`和`person[4]`可能会交换，`person[4]`和`person[5]`可能会交换。经过第一次循环后，`person[4]`的`salary`值可能会变为初始`person[5]`的`salary`值，即511.0。

答案：{'24317':'C'}

------

### 题目24318
问题：9.　　逐语句调试程序，当程序第20行for循环中的表达式“i++”执行后，i的值为2，此时temp的成员code的值是（　　　　）。
A.　　3
B.　　4
C.　　5
D.　　6


**解析如下：**

------

解析：当`i++`执行后，`i`的值为2，此时第20行的`for`循环已经执行了一次。在第一次循环中，`temp`用于交换`person[j]`和`person[j+1]`的值。第一次循环的最后一次交换可能是`person[4]`和`person[5]`，即`temp`被赋值为`person[4]`的值，初始`person[4]`的`code`值为5。

答案：{'24318':'C'}

------

### 题目24319
问题：10.　　当程序第29行的代码开始执行时，person[2]的成员name的值是（　　　　）。
A.　　“marit”
B.　　“jasen”
C.　　“peter”
D.　　“yoke”


**解析如下：**

------

解析：程序第20行到第28行的`for`循环对`person`数组按`salary`进行了升序排序。初始时`person[2]`的`name`值为"marit"。经过排序后，`person[2]`的位置会发生变化。根据初始`salary`值和排序逻辑，最终`person[2]`的`name`值会是"peter"。

答案：{'24319':'C'}

------

### 题目24320
问题：11.　　当程序第33行定义的函数printEmployee，实参和形参之间采用的参数传递方式是（　　　　）。
A.　　值传递
B.　　地址传递
C.　　引用传递
D.　　常量传递


**解析如下：**

------

解析：第33行定义的函数`printEmployee`的参数是`const Employee p`，这是一个常量值传递。虽然`p`是常量，但传递方式仍是值传递。

答案：{'24320':'A'}

------

