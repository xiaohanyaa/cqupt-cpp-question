## ch002_001
``` c++
1)　#include　<iostream>
2)　#include　<iomanip>
3)　using　namespace　std;
4)　int　main()
5)　{
6)　　　　unsigned　short　us　=　65535;
7)　　　　signed　short　ss　=　-1;
8)　　　　long　l;
9)　　　　l　=　us;　　
10)　　cout　<<　"unsigned　long　　　:";
11)　　cout　<<　setw(8)　<<　hex　<<　l　<<　","　<<　setw(8)　<<　dec　<<　l　<<　endl;
12)　　l　=　ss;　　
13)　　cout　<<　"signed　long　　　:";
14)　　cout　<<　setw(8)　<<　hex　<<　l　<<　","　<<　setw(8)　<<　dec　<<　l　<<　endl;
15)　　return　0;
16)　}

```
### 题目22726
问题：1.执行该程序，屏幕输出第一行为：
A.　unsigned　long　　:0000ffff,　　　65535
B.　unsigned　long　　:　　ffff,　　　65535
C.　unsigned　long　　:　　ffff,　　　-1
D.　unsigned　long　　:ffff0000,　　　-1


**解析如下：**

------

解析：
1. 程序定义了一个无符号短整型变量 `us` 并赋值为 65535，十六进制表示为 `0xffff`。
2. 程序将 `us` 赋值给长整型变量 `l`。
3. 输出时使用 `hex` manipulator 以十六进制形式输出 `l`，使用 `dec` manipulator 以十进制形式输出 `l`。
4. `setw(8)` 用于设置输出宽度为8个字符。

根据以上分析，第一行输出应为：
- 十六进制：`0000ffff`（因为 `setw(8)` 会补齐前导0）
- 十进制：`65535`

因此，正确答案是 A。

{'22726':'A'}

------

### 题目22727
问题：2.　执行该程序，屏幕输出第二行为：
A.　　signed　long　　　:0000ffff,　　　　　　-1
B.　　signed　long　　　:0000ffff,　　　65535
C.　　signed　long　　　:ffffffff,　　　　　　-1
D.　　signed　long　　　:ffffffff,　　　　　65535


**解析如下：**

------

解析：
1. 程序定义了一个有符号短整型变量 `ss` 并赋值为 -1。
2. 程序将 `ss` 赋值给长整型变量 `l`。
3. 输出时使用 `hex` manipulator 以十六进制形式输出 `l`，使用 `dec` manipulator 以十进制形式输出 `l`。
4. `setw(8)` 用于设置输出宽度为8个字符。

对于有符号短整型 -1，其十六进制表示为 `0xffff`，但在扩展到长整型时，会进行符号扩展，变为 `0xffffffff`。

因此，第二行输出应为：
- 十六进制：`ffffffff`
- 十进制：`-1`

所以，正确答案是 C。

{'22727':'C'}

------

### 题目22728
问题：3.把程序第6行修改为unsigned　short　us　=　65536，执行该程序，屏幕输出第一行为：
A.　unsigned　long　　　:　0000ffff,　　　65536
B.　unsigned　long　　　:　　　ffff,　　　65536
C.　unsigned　long　　　:　　　　0,　　　0
D.　unsigned　long　　　:　　　1000,　0


**解析如下：**

------

解析：
1. 将第6行修改为 `unsigned short us = 65536`。
2. `unsigned short` 类型的范围是 0 到 65535，因此赋值 65536 会发生溢出，实际存储的值为 0。
3. 程序将 `us` 赋值给长整型变量 `l`。
4. 输出时使用 `hex` manipulator 以十六进制形式输出 `l`，使用 `dec` manipulator 以十进制形式输出 `l`。
5. `setw(8)` 用于设置输出宽度为8个字符。

由于 `us` 实际存储的值为 0，所以 `l` 也为 0。

因此，第一行输出应为：
- 十六进制：`00000000`
- 十进制：`0`

所以，正确答案是 C。

{'22728':'C'}

------

### 题目22729
问题：4.把程序第7行修改为signed　short　ss　=　65535，执行该程序，屏幕输出第二行为：
A.　　signed　long　　　:0000ffff,　　　　　　-1
B.　　signed　long　　　:0000ffff,　　　65535
C.　　signed　long　　　:ffffffff,　　　　　　-1
D.　　signed　long　　　:ffffffff,　　　　　65535


**解析如下：**

------

解析：
1. 将第7行修改为 `signed short ss = 65535`。
2. `signed short` 类型的范围是 -32768 到 32767，因此赋值 65535 会发生溢出。
3. 在二进制表示中，65535 对应于 `0xffff`，但由于是 `signed short`，这会被解释为 -1。
4. 程序将 `ss` 赋值给长整型变量 `l`。
5. 输出时使用 `hex` manipulator 以十六进制形式输出 `l`，使用 `dec` manipulator 以十进制形式输出 `l`。
6. `setw(8)` 用于设置输出宽度为8个字符。

由于 `ss` 被解释为 -1，扩展到长整型时，会进行符号扩展，变为 `0xffffffff`。

因此，第二行输出应为：
- 十六进制：`ffffffff`
- 十进制：`-1`

所以，正确答案是 C。

{'22729':'C'}

------

### 题目22730
问题：5.　unsigned　short的最大正数是：
A.　　32768
B.　　32767
C.　　65535
D.　　65536


**解析如下：**

------

解析：
1. `unsigned short` 类型在 C++ 中通常占用 16 位。
2. 16 位无符号整数的范围是从 0 到 \(2^{16} - 1\)。
3. 计算 \(2^{16} - 1\) 得到 65535。

因此，`unsigned short` 的最大正数是 65535。

所以，正确答案是 C。

{'22730':'C'}

------

### 题目22731
问题：6.　unsigned　short表示的最小数是：
A.　　0
B.　　1
C.　　2
D.　　不确定


**解析如下：**

------

解析：
1. `unsigned short` 类型在 C++ 中是无符号整数，占用 16 位。
2. 无符号整数的范围从 0 开始，到 \(2^{16} - 1\) 结束。
3. 因此，`unsigned short` 能表示的最小数是 0。

所以，正确答案是 A。

{'22731':'A'}

------

### 题目22732
问题：7.　signed　short的最大正数是：
A.　　32768
B.　　32767
C.　　65535
D.　　65536


**解析如下：**

------

解析：
1. `signed short` 类型在 C++ 中通常占用 16 位。
2. 16 位有符号整数的范围是从 \(-2^{15}\) 到 \(2^{15} - 1\)。
3. 计算 \(2^{15} - 1\) 得到 32767。

因此，`signed short` 的最大正数是 32767。

所以，正确答案是 B。

{'22732':'B'}

------

### 题目22733
问题：8.　signed　short的最小负数是：
A.　　-32767
B.　　-32768
C.　　-65535
D.　　-65536


**解析如下：**

------

解析：
1. `signed short` 类型在 C++ 中通常占用 16 位。
2. 16 位有符号整数的范围是从 \(-2^{15}\) 到 \(2^{15} - 1\)。
3. 计算 \(-2^{15}\) 得到 -32768。

因此，`signed short` 的最小负数是 -32768。

所以，正确答案是 B。

{'22733':'B'}

------

### 题目22734
问题：9.　char的最大正数是：
A.　　127
B.　　128
C.　　255
D.　　256


**解析如下：**

------

解析：
1. `char` 类型在 C++ 中通常占用 8 位。
2. 默认情况下，`char` 是有符号的，其范围是从 \(-2^{7}\) 到 \(2^{7} - 1\)。
3. 计算 \(2^{7} - 1\) 得到 127。

因此，`char` 的最大正数是 127。

所以，正确答案是 A。

{'22734':'A'}

------

### 题目22735
问题：10.　char的最小负数是：
A.　　-127
B.　　-128
C.　　-255
D.　　-256


**解析如下：**

------

解析：
1. `char` 类型在 C++ 中通常占用 8 位。
2. 默认情况下，`char` 是有符号的，其范围是从 \(-2^{7}\) 到 \(2^{7} - 1\)。
3. 计算 \(-2^{7}\) 得到 -128。

因此，`char` 的最小负数是 -128。

所以，正确答案是 B。

{'22735':'B'}

------

