## ch010_006
``` c++
1)　　#include<iostream>
2)　　using　namespace　std;
3)　　unsigned　add(unsigned　a,　unsigned　b);
4)　　signed　unaryMinus(unsigned　b);
5)　　signed　subtraction(unsigned　a,　unsigned　b);
6)　　unsigned　getSign(signed　a);
7)　　unsigned　getPositive(signed　i);
8)　　signed　multiply(signed　a,　signed　b);
9)　　int　main(){
10)　　　　　　signed　a,　b;
11)　　　　　　cin　>>　a　>>　b;
12)　　　　　　cout　<<　"a*b="　<<　multiply(a,　b)　<<　endl;
13)　　　　　　system("pause");
14)　　}
15)　　unsigned　add(unsigned　a,　unsigned　b){
16)　　　　　　unsigned　s,　c;
17)　　　　　　while　(b　!=　0){
18)　　　　　　　　　　s　=　a^b;
19)　　　　　　　　　　c　=　(a&b)　<<　1;
20)　　　　　　　　　　a　=　s;
21)　　　　　　　　　　b　=　c;
22)　　　　　　}
23)　　　　　　return　a;
24)　　}
25)　　signed　unaryMinus(unsigned　b){
26)　　　　　　unsigned　ui　=　(unsigned)b;
27)　　　　　　return　(signed)add(~ui,　1);　
28)　　}
29)　　signed　subtraction(unsigned　a,　unsigned　b){
30)　　　　　　return　(signed)add(a,　(unsigned)unaryMinus(b));　
31)　　}
32)　　unsigned　getSign(signed　a){
33)　　　　　　unsigned　lenType　=　32;
34)　　　　　　return　a　>>　lenType　-　1;
35)　　}
36)　　unsigned　getPositive(signed　i){
37)　　　　　　if　(getSign(i))
38)　　　　　　　　　　return　unaryMinus(i);
39)　　　　　　else
40)　　　　　　　　　　return　(unsigned)i;
41)　　}
42)　　signed　multiply(signed　a,　signed　b){
43)　　　　　　bool　flag　=　true;
44)　　　　　　if　(getSign(a)　==　getSign(b))
45)　　　　　　　　　　flag　=　false;
46)　　　　　　unsigned　ua,　ub;
47)　　　　　　ua　=　getPositive(a);
48)　　　　　　ub　=　getPositive(b);
49)　　　　　　unsigned　result　=　0;
50)　　　　　　while　(ub)
51)　　　　　　{
52)　　　　　　　　　　if　(ub　&　1)
53)　　　　　　　　　　　　　　result　=　add(result,　ua);
54)　　　　　　　　　　ua　=　(ua　<<　1);　
55)　　　　　　　　　　ub　=　(ub　>>　1);　
56)　　　　　　}
57)　　　　　　signed　r;
58)　　　　　　if　(flag)
59)　　　　　　　　　　r　=　unaryMinus(result);
60)　　　　　　else
61)　　　　　　　　　　r　=　(signed)result;
62)　　　　　　return　r;
63)　　}

```
### 题目24080
问题：48.　　运行代码时，将从以下哪个函数开始执行：
A.　　add
B.　　unaryMinus
C.　　multiply
D.　　main


**解析如下：**

------

解析：C++程序从main函数开始执行。

答案：{'24080':'D'}

------

### 题目24081
问题：49.　　代码第43行中，关于布尔变量flag的说法错误的是：
A.　　取值一直为true
B.　　当参数a和b的正负符号不一致时，取值为true
C.　　当参数a和b的正负符号一致时，取值为false
D.　　取值影响后续代码执行


**解析如下：**

------

解析：第43行初始化flag为true，但后续根据a和b的符号会改变其值。因此，A选项“取值一直为true”是错误的。

答案：{'24081':'A'}

------

### 题目24082
问题：50.　　代码第33行，表达式lenType　=　32中的32，不可以替换成：
A.　　sizeof(a)
B.　　sizeof(signed)
C.　　sizeof(int)
D.　　a


**解析如下：**

------

解析：第33行中的32代表的是数据类型的位数，用于右移操作。`sizeof(a)`、`sizeof(signed)`和`sizeof(int)`都可以表示数据类型的位数，而`a`是一个变量，不能表示位数。

答案：{'24082':'D'}

------

### 题目24083
问题：51.　　代码第34行，关于getSign函数的返回值，以下说法不正确的是：
A.　　返回值只有两种取值：1或0
B.　　若返回值为1，表示参数a为负数
C.　　若返回值为0，表示参数a为正数
D.　　返回值是通过对参数a做左移操作获得的


**解析如下：**

------

解析：第34行中的`getSign`函数通过右移操作（而不是左移操作）来获取符号位，因此D选项不正确。

答案：{'24083':'D'}

------

### 题目24084
问题：52.　　代码37行中，关于getSign函数返回值做分支判断条件，以下说法正确的是：
A.　　返回值为1，判为真
B.　　返回值为1，判为假
C.　　返回值为0，判为真
D.　　返回值为非零，判为假


**解析如下：**

------

解析：在C++中，非零值都被视为真（true），零值被视为假（false）。因此，`getSign`函数返回值为1时，判断为真。

答案：{'24084':'A'}

------

### 题目24085
问题：53.　　关于代码第50~56行，以下说法错误的是：
A.　　当变量ub为0时，循环结束；
B.　　每执行一次循环，变量result将在原值上加ua
C.　　每执行一次循环，变量ua将左移1位
D.　　每执行一次循环，变量ub将右移1位


**解析如下：**

------

解析：第50~56行的循环中，变量`result`只在`ub & 1`为真时才加上`ua`，并不是每次循环都加。因此，B选项说法错误。

答案：{'24085':'B'}

------

